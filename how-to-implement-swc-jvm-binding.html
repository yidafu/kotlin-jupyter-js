<!DOCTYPE html>
<html>
<head>
  <title>docs/how-to-implement-swc-jvm-binding.md</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.0/github-markdown.min.css">
</head>
<body>
<h1 id="how-to-implement-swc-jvm-binding">How to implement SWC JVM binding</h1>
<p>Translated with DeepL.com (free version)</p>
<h2 id="background">Background</h2>
<p>In the process of using Kotlin Jupiter Kennel, I found that there is no 3D drawing library, and I can only use JS to draw data. We can only use JS to draw the data by using the <code>HTML(...)</code> function to write JS, which is very inconvenient. So I wrote the <a href="https://github.com/yidafu/kotlin-jupyter-js">kotlin-jupyter-js</a> plugin to support <code>%js</code> line magics. The core problem with the <code>kotlin-jupyter-js</code> plugin is: compiling JS code into ASTs is supported in the JVM. The core problem with the <code>kotlin-jupyter-js</code> plugin is that the JVM supports compiling JS code into ASTs.</p>
<p>My idea is to implement SWC&#39;s JVM binding to solve this problem, SWC itself provides Node binding, so JVM binding is not that difficult to implement. Moreover, SWC supports TS/JSX compilation, which allows <code>kotlin-jupyter-js</code> to support <code>typescript</code> and <code>React</code>.</p>
<h2 id="implementation-ideas">Implementation Ideas</h2>
<p>The SWC JVM binding implementation is divided into two parts: 1) compiling the SWC Rust code into a JNI dynamic library, and 2) the JVM side, which implements the configuration classes and AST classes.</p>
<p>SWC is for JS and only provides support for Node binding, we need to refer to Node binding to implement JVM binding.</p>
<p>SWC Node binding exposes API output and input parameters are JSON strings, in Node, JSON strings can be easily converted to objects, but in JVM, you need to declare the corresponding classes.</p>
<blockquote>
<p>SWC provides WASM binding, you can encapsulate SWC based on WASM, the advantage is that you don&#39;t need to implement JNI binding, but you need to introduce WASM Runtime, so we don&#39;t consider it.</p>
</blockquote>
<h2 id="swc-binding">SWC binding</h2>
<h3 id="rust-jni-ffis">Rust JNI FFIs</h3>
<p>Compiling Rust into a JNI dynamic library requires the Rust JNI FFI, which is supported by using <a href="https://crates.io/crates/jni">jni</a>.</p>
<p>This library provides an easy way to bridge Rust and Java, see the official <code>jni</code> example.</p>
<p>On the JVM side of the code.</p>
<pre><code class="lang-kotlin">class HelloWorld {
    init {
        System.loadLibrary(&quot;mylib&quot;);
    }

    external fun hello(input: String): String;
}
</code></pre>
<p>In Rust code it&#39;s just a matter of writing the glue code.</p>
<pre><code class="lang-rust">#[no_mangle]
pub extern &quot;system&quot; fn Java_HelloWorld_hello&lt;&#39;local&gt;(mut env: JNIEnv&lt;&#39;local&gt;, class: JClass&lt;&#39;local&gt;, input: JString&lt;&#39;local&gt;) -&gt; jstring {
    let input: String =
        env.get_string(&amp;input).expect(&quot;Couldn&#39;t get java string!&quot;).into();

    // your business logic
    let output = env.new_string(format!(&quot;Hello, {}!&quot;, input))
        .expect(&quot;Couldn&#39;t create java string!&quot;);

    output.into_raw()
}
</code></pre>
<p>Calling <code>HelloWorld().hello(&quot;JNI&quot;)</code> through JNI will call the Rust code returning <code>Hello, JNI!</code>.</p>
<p>The declaration of the bridge function in the above Rust code is quite long, you can use <a href="https://crates.io/crates/jni_fn">jni_fn</a> to generate the bridge function declaration automatically by macro to simplify the declaration.</p>
<pre><code class="lang-rust">#[jni_fn(&quot;HelloWorld&quot;)]
pub fn hello&lt;&#39;local&gt;(...) -&gt; jstring
</code></pre>
<p>With <code>jni</code> and <code>jni_fn</code> we can compile Rust code into JNI dynamic libraries.</p>
<h3 id="binding">Binding</h3>
<p>SWC Node binding offers the following methods.</p>
<ul>
<li>transform<ul>
<li>transform</li>
<li>transformSync</li>
<li>transformFile</li>
<li>transformFileSync</li>
</ul>
</li>
<li>parse<ul>
<li>parse</li>
<li>parseSync</li>
<li>parseFile</li>
<li>parseFileSync</li>
</ul>
</li>
<li>minify<ul>
<li>minify</li>
<li>minifySync</li>
</ul>
</li>
<li>print<ul>
<li>print</li>
<li>printSync</li>
</ul>
</li>
</ul>
<p>SWC Node binding provides synchronous and asynchronous methods via <a href="https://crates.io/crates/napi">napi</a>. However, the JVM&#39;s FFI <code>jni</code> doesn&#39;t only support asynchrony, so we only implement the synchronous APIs: <code>transformSync</code>,<code>transformFileSync</code>,<code>parseSync</code>,<code>parseFileSync</code>,<code>minifySync</code>,<code>printSync</code>.</p>
<h3 id="pase_sync">pase_sync</h3>
<p>Below is an example of <code>pase_sync</code> to explain how to implement it.</p>
<h4 id="dependencies">Dependencies</h4>
<p>SWC itself only considers Node binding.<a href="https://crates.io/crates/swc_core">swc_core</a> implements the logic of binding to Node, aggregating other SWC sub-package dependencies. NMP package <code>@swc/core</code> also wraps <code>swc_core</code>. We can&#39;t use the <code>swc_core</code> library directly, we need to replace other SWC subpackage calls.</p>
<p>For example, <code>Compiler</code> from <code>swc_core</code>:</p>
<pre><code class="lang-rs">use swc_core::{
    base::{
        Compiler,
    },
}
</code></pre>
<p>Needs to be changed to be introduced from <a href="https://crates.io/crates/swc">swc</a>.</p>
<pre><code class="lang-rust">use swc::Compiler;
</code></pre>
<p>All SWC-related dependencies after <code>swc_core</code> conversion.</p>
<pre><code class="lang-toml">[dependencies]
# ...
swc = &quot;0.270.25&quot;
swc_common = &quot;0.33.9&quot;
swc_ecma_ast = { version =&quot;0.110.10&quot;, features = [&quot;serde-impl&quot;] }
swc_ecma_transforms = &quot;0.227.19&quot;
swc_ecma_transforms_base = &quot;0.135.11&quot;
swc_ecma_visit = &quot;0.96.10&quot;
swc_ecma_codegen = &quot;0.146.39&quot;
# ...
</code></pre>
<h4 id="entry-exit-parameter">entry/exit parameter</h4>
<p>Theoretically, what needs to be done is simple: replace all <code>napi</code> related logic with <code>jni</code>. We don&#39;t need to change how SWC implements the specific functionality.</p>
<p>See <a href="https://github.com/swc-project/swc/tree/main/bindings/binding_core_node">SWC - binding_core_node</a> for the <code>pase_sync</code> implementation <a href="https://github.com/swc-project/swc/blob/828190c035d61e6521280e2260c511bc02b81327/bindings/binding_core_node/ src/parse.rs#L168">binding_core_node /src/parse.rs#L168</a>, <code>parseSync</code> copies most of the logic directly, but requires changes to the handling of incoming and outgoing parameters.</p>
<p>The <code>pase_sync</code> implementation of <code>binding_core_node</code>:</p>
<pre><code class="lang-rust">#[napi]
pub fn parse_sync(src: String, opts: Buffer, filename: Option&lt;String&gt;) -&gt; napi::Result&lt;String&gt; {
    // ...


    Ok(serde_json::to_string(&amp;program)?)
}
</code></pre>
<p>Signature changes and entry/exit parameter processing are required:</p>
<pre><code class="lang-rust">#[jni_fn(&quot;dev.yidafu.swc.SwcNative&quot;)]
pub fn parseSync(mut env: JNIEnv, _: JClass, code: JString, options: JString, filename: JString) -&gt; jstring {
    // process parameter
    let src: String = env
        .get_string(&amp;code)
        .expect(&quot;Couldn&#39;t get java string!&quot;)
        .into();
    let opts: String = env
        .get_string(&amp;options)
        .expect(&quot;Couldn&#39;t get java string!&quot;)
        .into();
    let filename: String = env
        .get_string(&amp;filename)
        .expect(&quot;Couldn&#39;t get java string!&quot;)
        .into();

    // ...

    // process return value
    let output = env
        .new_string(ast_json)
        .expect(&quot;Couldn&#39;t create java string!&quot;);

    output.into_raw()
}
</code></pre>
<p>Getting a string passed by the JVM requires a call to <code>get_string</code> of <code>JNIEnv</code>.</p>
<p>Converting a Rust string to a Java string also requires a call to <code>new_string</code> of <code>JNIEnv</code> before converting to a <code>jstring</code> type.</p>
<h4 id="exception-handling">Exception Handling</h4>
<p>If SWC fails to process JS code (e.g. JS code has syntax errors), it needs to throw an exception to the JVM, which will be handled by the JVM side.</p>
<p>The code thrown by Rust is first caught and then converted into an exception thrown by the JVM.</p>
<p>The <code>binding_core_node</code> handler implements the <code>MapErr&lt;T&gt;</code> trait for <code>Result</code>, which converts the Rust exception to a <code>napi</code> exception via the <code>convert_err</code> method, and finally throws it in the Node.</p>
<p>Exception handling in SWC <a href="https://github.com/swc-project/swc/blob/ 828190c035d61e6521280e2260c511bc02b81327/bindings/binding_core_node/src/parse.rs#L179">swc/bindings/binding_core_node/src/parse.rs#L179</a></p>
<pre><code class="lang-rust">let program = try_with(c.cm.clone(), false, ErrorFormat::Normal, |handler| {
    // ....
}).convert_err()?;
</code></pre>
<p>We need to throw JVM exceptions, so implement the JVM&#39;s <code>MapErr&lt;T&gt;</code> trait to turn Rust exceptions into <code>jni</code> exceptions for <code>jni</code> to throw to the JVM.</p>
<p>Copy the SWC&#39;s <code>MapErr&lt;T&gt;</code> trait.</p>
<pre><code class="lang-rust">pub trait MapErr&lt;T&gt;: Into&lt;Result&lt;T, anyhow::Error&gt;&gt; {
    fn convert_err(self) -&gt; SwcResult&lt;T&gt; {
        self.into().map_err(|err| SwcException::SwcAnyException {
            msg: format!(&quot;{:?}&quot;, err),
        })
    }
}
</code></pre>
<p><code>Result</code> implements <code>MapErr&lt;T&gt;</code>.</p>
<pre><code class="lang-rust">impl&lt;T&gt; MapErr&lt;T&gt; for Result&lt;T, anyhow::Error&gt; {}
</code></pre>
<p>Here <code>jni</code> throws an exception and it should be noted that the function still needs to return a value, usually an empty string. Here <a href="https://github.com/jni-rs/jni-rs/issues/76">jni-rs#76</a> explains why.</p>
<blockquote>
<p>You still have to return to the JVM, even if you&#39;ve thrown an exception. Remember that unwinding across the ffi boundary is always undefined behavior, so any panics need to be caught and recovered from in your extern functions.</p>
</blockquote>
<p>The final exception is handled like this</p>
<pre><code class="lang-rust">let result = try_with(c.cm.clone(), false, ErrorFormat::Normal, |handler| {
    // ...
}).convert_err();

match result {
    Ok(program) =&gt; {
        // ...
    }
    Err(e) =&gt; {
        match e {
            SwcException::SwcAnyException { msg } =&gt; {
                env.throw(msg).unwrap();
            }
        }
        return JString::default().into_raw();
    }
}
</code></pre>
<h3 id="swcnative">SwcNative</h3>
<p>Implementation of Rust compiled into a dynamic library, the next step will need to implement the JVM side of the glue code, the following is the Kotlin implementation.</p>
<pre><code class="lang-kotlin">class SwcNative {
    init {
        System.loadLibrary(&quot;swc_jni&quot;)
    }

    @Throws(RuntimeException::class)
    external fun parseSync(code: String, options: String, filename: String?): String
}
</code></pre>
<p>When the JVM loads <code>swc_jni</code>, it looks for dynamic libraries from the filesystem as a rule, but not from the <code>resources</code> directory of the jar. So, by <code>System.loadLibrary(&quot;swc_jni&quot;)</code> if there is no <code>swc_jni</code> dynamic library locally, it will fail to load. The user installs from maven and there is definitely no <code>swc_jni</code> locally.</p>
<p>Solution, refer to this answer <a href="https://stackoverflow.com/questions/23189776/load-native-library-from-class-path">Load Native Library from Class path</a>, if <code>System.loadLibrary(&quot;swc_jni&quot;)</code> fails to load, then copy the jar&#39;s dynamic library to a temporary directory and load it again.</p>
<pre><code class="lang-kotlin">    init {
        try {
            System.loadLibrary(&quot;swc_jni&quot;)
        } catch (e: UnsatisfiedLinkError) {
            // 加载失败，复制DLL到临时目录
            val dllPath = DllLoader.copyDll2Temp(&quot;swc_jni&quot;)
            // 再次加载
            System.load(dllPath)
        }
    }
</code></pre>
<h3 id="summary">Summary</h3>
<p>Like the other methods just implement them like <code>parse_sync</code>.</p>
<p>At this point we can compile JS in the JVM.</p>
<pre><code class="lang-kotlin">SwcNative().parseSync(
    &quot;var foo = &#39;bar&#39;&quot;, 
    &quot;&quot;&quot;{&quot;syntax&quot;: &quot;ecmascript&quot;;}&quot;&quot;&quot;,
    &quot;test.js&quot;,
)

</code></pre>
<p>&lt;details&gt;<br>&lt;summary&gt;output string&lt;/summary&gt;<br><br><code>json
{
  &quot;type&quot;: &quot;Module&quot;,
  &quot;span&quot;: {
    &quot;start&quot;: 0,
    &quot;end&quot;: 15,
    &quot;ctxt&quot;: 0
  },
  &quot;body&quot;: [
    {
      &quot;type&quot;: &quot;VariableDeclaration&quot;,
      &quot;span&quot;: {
        &quot;start&quot;: 0,
        &quot;end&quot;: 15,
        &quot;ctxt&quot;: 0
      },
      &quot;kind&quot;: &quot;var&quot;,
      &quot;declare&quot;: false,
      &quot;declarations&quot;: [
        {
          &quot;type&quot;: &quot;VariableDeclarator&quot;,
          &quot;span&quot;: {
            &quot;start&quot;: 4,
            &quot;end&quot;: 15,
            &quot;ctxt&quot;: 0
          },
          &quot;id&quot;: {
            &quot;type&quot;: &quot;Identifier&quot;,
            &quot;span&quot;: {
              &quot;start&quot;: 4,
              &quot;end&quot;: 7,
              &quot;ctxt&quot;: 2
            },
            &quot;value&quot;: &quot;foo&quot;,
            &quot;optional&quot;: false,
            &quot;typeAnnotation&quot;: null
          },
          &quot;init&quot;: {
            &quot;type&quot;: &quot;StringLiteral&quot;,
            &quot;span&quot;: {
              &quot;start&quot;: 10,
              &quot;end&quot;: 15,
              &quot;ctxt&quot;: 0
            },
            &quot;value&quot;: &quot;bar&quot;,
            &quot;raw&quot;: &quot;&#39;bar&#39;&quot;
          },
          &quot;definite&quot;: false
        }
      ]
    }
  ],
  &quot;interpreter&quot;: null
}</code><br><br>&lt;/code&gt;<br>&lt;/details&gt;

</p>
<h2 id="kotlin-ast-dsl">Kotlin AST DSL</h2>
<p>Now that we get the AST JSON string, it is still inconvenient if we want to manipulate the AST. We need the JSON string to convert it to a class so that traversing and modifying it will be easy.</p>
<p>Also, the second <code>options</code> of <code>parseSync</code> is not type aware and needs to be constrained to a configuration item.</p>
<p>So how do we implement type descriptions for SWC ASTs and configuration item parameters in Kotlin?</p>
<p>I&#39;ve tried an AI conversion from Rust to Kotlin and it works pretty well. The only problem is that it requires kryptonite, and I admit that lack of money is my problem.</p>
<p>Writing SWC class definitions from scratch? I&#39;m afraid there&#39;s a lot of work to be done, SWC has 200+ ASTs and configuration item types.</p>
<p>The best solution is to generate Kotlin classes via scripts. As it happens, SWC provides the TS declaration file <a href="https://www.npmjs.com/package/@swc/types">@swc/types</a>.</p>
<h3 id="-swc-types">@swc/types</h3>
<p>When you open the declaration file for <code>@swc/types</code>, it is full of <code>type</code> and <code>interface</code> declarations with a very simple structure.</p>
<p>It can be divided into the following cases.</p>
<ol>
<li>type alias<ol>
<li>literal union type: <code>type T = &#39;foo&#39; | &#39;bar&#39;</code></li>
<li>primary union type: <code>type T = string | number</code></li>
<li>type alias and object literal type: <code>type T = S &amp; { foo: string }</code></li>
<li>type alias union type: <code>type T = S | E</code></li>
</ol>
</li>
<li>interface</li>
</ol>
<p>The case of Type alias is relatively complex, mainly because of the flexibility of JS.</p>
<h3 id="type-alias">type alias</h3>
<p>For some special cases we need to reduce the dynamics of types to make it easier for us to work with them.</p>
<p>Like <code>T | T[]</code> we can convert to <code>T[]</code> to avoid not being able to define the type in Kotlin.</p>
<p>For example:</p>
<pre><code class="lang-ts">export interface Config {
    test?: string | string[];
    // ...
}
</code></pre>
<p>Just convert:</p>
<pre><code class="lang-kotlin">class Config {
    var test: Array&lt;String&gt;? = null
}
</code></pre>
<p>A literal union type like <code>props: &#39;foo&#39; | &#39;bar&#39;</code> should be converted directly to the base type: <code>val props: String?</code>.</p>
<p>A <code>type T = S &amp; { foo: string }</code> requires that the object literal type be extracted as a separate type, with T inheriting from S and the extracted new type. Conversion to kotlin should look like this:</p>
<pre><code class="lang-kotlin">interface BaseT {
    val foo: String;
}

class T : S, BaseT {}
</code></pre>
<h3 id="interface">interface</h3>
<p>For <code>interface</code> processing, it is divided into 3 parts: 1. TS interface to Kotlin class; 2. inheritance; 3. serialization.</p>
<h4 id="ts-interface-to-kotlin-class">TS interface to Kotlin class</h4>
<p>Define a <code>KotlinClass</code> to represent the Kotlin class to be converted. Implement <code>toString()</code> to convert it to a Kotlin class.</p>
<pre><code class="lang-ts">export class KotlinClass {
    klassName: string = &#39;&#39;;
    headerComment: string = &#39;&#39;
    annotations: string[] = []
    modifier: string = &#39;&#39;
    parents: string[] = []
    properties: KotlinClassProperty[] = []
}
</code></pre>
<p>The <code>KotlinClass</code> is generated by traversing the AST of the TS interface.</p>
<p>When traversing interface properties, you need to recursively traverse the properties of the parent class. Properties inherited from the parent type need to set <code>KotlinClassProperty.isOverride</code> to true to facilitate the generation of kotlin classes with the <code>override</code> modifier.</p>
<pre><code class="lang-ts">class KotlinClassProperty {
    modifier: string = &#39;var&#39;
    name: string = &#39;&#39;
    type: string = &#39;&#39;
    comment: string = &#39;&#39;
    defaultValue: string = &#39;&#39;
    isOverride: boolean = false
    discriminator: string = &#39;type&#39;
}
</code></pre>
<h4 id="inheritance">Inheritance</h4>
<p>The parent interface from which the TS interface directly inherits is simply added to the <code>KotlinClass.parents</code> array.</p>
<p>However, <code>type T = S | E</code> needs to be handled separately.</p>
<p>As an example</p>
<pre><code class="lang-ts">export interface VariableDeclarator extends Node, HasSpan {
    init?: Expression;

    // other props...
}

export type Expression =
    | ThisExpression
    | ArrayExpression
    | ....

export interface ArrayExpression extends ExpressionBase  {
    // ...
}
</code></pre>
<p>Here Expression is the parent of all <code>XxxExpression</code>. This makes <code>variableDeclarator.init = thisExpression</code> or <code>variableDeclarator.init = arrayExpression</code> assignments legal.</p>
<p>Because <code>Expression</code> is a type alias in TS, converting kotlin turns it into an empty interface. Converting to Kotlin results in something like this</p>
<pre><code class="lang-kotlin">interface Expression {}

class VariableDeclarator : Node, HasSpan {
    val init: Expression?;

    // other props...
}
class ArrayExpression : ExpressionBase, Expression {
    // ...
}
</code></pre>
<p>So, for <code>type T = S | E</code>, <code>T</code> is the parent of <code>S</code> and <code>E</code>, and <code>T</code> needs to be added to the <code>KotlinClass.parents</code> array of <code>S</code>,<code>E</code>.</p>
<h4 id="serialization">Serialization</h4>
<p>When serializing AST nodes, one encounters problems with polymorphic serialization.</p>
<p>For example, serialize <code>Expression</code>, and <code>Expression</code> is an empty interface, then <code>toJson</code> doesn&#39;t know how to deal with <code>ThisExpression</code> and <code>ArrayExpression</code> properties, and then it can only throw an exception or output an empty object, which don&#39;t meet our expectation.</p>
<pre><code class="lang-kotlin">val thisExpression: ThisExpression = ThisExpression()
val arrayExpression: ArrayExpression = ArrayExpression()

var expression: Expression = thisExpression
toJson(expression)

expression = arrayExpression
toJson(expression)
</code></pre>
<p>The same goes for deserialization. <code>parseJson</code> also doesn&#39;t know whether to convert a string to <code>ThisExpression</code> or <code>ArrayExpression</code>.</p>
<pre><code class="lang-kotlin">val thisExpression = &quot;&quot;&quot; {&quot;type&quot;:&quot;ThisExpression&quot;, &quot;props&quot;: &quot;any value&quot; } &quot;&quot;&quot;
val arrayExpression = &quot;&quot;&quot; {&quot;type&quot;:&quot;ThisExpression&quot;, &quot;elements&quot;: [] } &quot;&quot;&quot;

var expression: Expression = parseJson(thisExpression)
var expression: Expression = parseJson(arrayExpression)
</code></pre>
<p>Serialization using kotlinx serialization, which supports <a href="https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/polymorphism.md">polymorphic serialization</a>, requires transforming the kotlin code.</p>
<p>Annotate the class with <code>JsonClassDiscriminator</code> to indicate by which field the type is distinguished, and <code>SerialName</code> to indicate the name of the type after serialization. Deserialization can find the specific type based on this type name.</p>
<pre><code class="lang-kotlin">interface ArrayExpression : ExpressionBase, Expression {
    // ....
}

@Serializable
@JsonClassDiscriminator(&quot;type&quot;)
@SerialName(&quot;ArrayExpression&quot;)
class ArrayExpressionImpl : ArrayExpression {
    // ...
}

interface ThisExpression : ExpressionBase, Expression {
    // ....
}

@Serializable
@JsonClassDiscriminator(&quot;type&quot;)
@SerialName(&quot;ThisExpression&quot;)
class ThisExpressionImpl : ThisExpression {
    // ....
}

</code></pre>
<p>In order for serialization and deserialization to be able to correctly find specific types, it is also necessary to define <code>SerializersModule</code>.</p>
<pre><code class="lang-kotlin">val swcSerializersModule = SerializersModule {
    // ...
    polymorphic(Expression::class) {
        subclass(ThisExpressionImpl::class)
        subclass(ArrayExpressionImpl::class)
        // ...
    }

    polymorphic(ThisExpression::class) {
        subclass(ThisExpressionImpl::class)
    }

    polymorphic(ArrayExpression::class) {
        subclass(ArrayExpressionImpl::class)
    }
    // ...
}
</code></pre>
<p>This allows normal serialization of polymorphic types</p>
<pre><code class="lang-kotlin">val json = Json {
    classDiscriminator = &quot;syntax&quot;
    serializersModule = configSerializer
}

json.decodeFromString&lt;Expression&gt;(&quot;&quot;&quot; {&quot;type&quot;:&quot;ThisExpression&quot;, &quot;elements&quot;: [] } &quot;&quot;&quot;)

val arrayExpression: Expression = ArrayExpression()
json.encodeToString&lt;Expression&gt;(arrayExpression)
</code></pre>
<h3 id="dsl">DSL</h3>
<p>We have generated class definitions for ASTs and configuration items, and would find it less elegant and convenient to build configuration or ASTs directly using classes.</p>
<pre><code class="lang-js">const foo = &#39;bar&#39;
</code></pre>
<p>&lt;details&gt;<br>&lt;summary&gt;SWC compile output string&lt;/summary&gt;<br><br><code>json
    {
      &quot;type&quot;: &quot;VariableDeclaration&quot;,
      &quot;span&quot;: {
        &quot;start&quot;: 0,
        &quot;end&quot;: 17,
        &quot;ctxt&quot;: 0
      },
      &quot;kind&quot;: &quot;const&quot;,
      &quot;declare&quot;: false,
      &quot;declarations&quot;: [
        {
          &quot;type&quot;: &quot;VariableDeclarator&quot;,
          &quot;span&quot;: {
            &quot;start&quot;: 6,
            &quot;end&quot;: 17,
            &quot;ctxt&quot;: 0
          },
          &quot;id&quot;: {
            &quot;type&quot;: &quot;Identifier&quot;,
            &quot;span&quot;: {
              &quot;start&quot;: 6,
              &quot;end&quot;: 9,
              &quot;ctxt&quot;: 2
            },
            &quot;value&quot;: &quot;foo&quot;,
            &quot;optional&quot;: false,
            &quot;typeAnnotation&quot;: null
          },
          &quot;init&quot;: {
            &quot;type&quot;: &quot;StringLiteral&quot;,
            &quot;span&quot;: {
              &quot;start&quot;: 12,
              &quot;end&quot;: 17,
              &quot;ctxt&quot;: 0
            },
            &quot;value&quot;: &quot;bar&quot;,
            &quot;raw&quot;: &quot;&#39;bar&#39;&quot;
          },
          &quot;definite&quot;: false
        }
      ]
    }</code><br>&lt;/details&gt;

</p>
<p>The JS code above, if we Kotlin build the AST</p>
<pre><code class="lang-kotlin">VariableDeclarationImpl().apply {
    span = Span(0, 17, 0)
    kind = &#39;const&#39;
    declare = false
    declarations = arrayOf(
        VariableDeclaratorImpl().apply {
            span = Span(6, 17, 0)
            id = IdentifierImpl().apply {
                span = span(5, 9, 0)
                value = &quot;foo&quot;
            }
            init = StringLiteralImpl().apply {
                span = Span(12,17, 0)
                value = &quot;bar&quot;
                raw = &quot;&#39;bar&#39;&quot;
            }
        }
    )
}
</code></pre>
<p>Simplified property settings are invoked via <code>apply</code>. Relative to spaghetti code, it&#39;s already cleaner via <code>apply</code>. It could be a bit more succinct.</p>
<pre><code class="lang-kotlin">variableDeclaration  {
    span = span(0, 17, 0)
    kind = &#39;const&#39;
    declare = false
    declarations = arrayOf(
        variableDeclaratorImpl {
            span = span(6, 17, 0)
            id = identifier {
                span = span(5, 9, 0)
                value = &quot;foo&quot;
            }
            init = stringLiteral {
                span = span(12,17, 0)
                value = &quot;bar&quot;
                raw = &quot;&#39;bar&#39;&quot;
            }
        }
    )
}
</code></pre>
<p>DSL is now very much like outputting AST JSON and is very simple and straightforward to write.</p>
<p>Classes that require DSL writing require the <code>SwcDslMarker</code> annotation marker. The <code>SwcDslMarker</code> is mainly to restrict the scope and avoid accessing the outer scope.</p>
<pre><code class="lang-kotlin">@DslMarker
annotation class SwcDslMarker

@SwcDslMarker
class VariableDeclarationImpl {
    // ...
}

fun variableDeclaration(block: VariableDeclaration.() -&gt; Unit): VariableDeclaration {
    return VariableDeclarationImpl().apply(block)
}
</code></pre>
<p>You can refer to the official documentation for how to implement it: <a href="https://kotlinlang.org/docs/type-safe-builders.html#scope-control-dslmarker">kotlin -- Type-safe builders</a></p>
<h4 id="dsl-extension-function">DSL extension function</h4>
<pre><code class="lang-kotlin">interface VariableDeclarator : Node, HasSpan {
    val init: Expression?;
    // other props...
}
</code></pre>
<p>For the <code>VariableDeclarator</code> interface, its init field type is <code>Expression</code>, meaning that its right value can be any subtype of <code>arrayExpression</code>, <code>thisExpression</code>, and so on.</p>
<pre><code class="lang-kotlin">variableDeclarator {
    init = arrayExpression { ... }
    // or
    init = thisExpression { ... }
}
</code></pre>
<p>So for <code>VariableDeclarator</code> it should have methods to create all <code>Expression</code> subclasses. The creation of <code>Expression</code> subclasses is added by extending the function to do so.</p>
<p>When we parse <code>@swc/types</code> declaration file, we need to check the type of the attribute, if it is converted to Kotlin and is a class, then find out all its non-intermediate subclasses, and then generate extension functions for it.</p>
<pre><code class="lang-kotlin">fun VariableDeclarator.arrayExpression(block: ArrayExpression.() -&gt; Unit): ArrayExpression {
    return ArrayExpressionImpl().apply(block)
}
</code></pre>
<p>This allows the <code>Expression</code> class to be constructed from the <code>arrayExpression {}</code> function in <code>variableDeclarator {}</code>.</p>
<h4 id="templateliteral-vs-tstemplateliteraltype"><code>TemplateLiteral</code> vs <code>TsTemplateLiteralType</code></h4>
<p>There&#39;s another special case to deal with here. <code>TemplateLiteral</code> conflicts with <code>TsTemplateLiteralType</code>, whose <code>type</code> is <code>&quot;TemplateLiteral&quot;</code>. This makes DSL-built ASTs unserializable. See the definition of a structure in rust.</p>
<pre><code class="lang-rust">// https://github.com/swc-project/swc/blob/828190c035d61e6521280e2260c511bc02b81327/crates/swc_ecma_ast/src/typescript.rs#L823
#[ast_node(&quot;TemplateLiteral&quot;)]
#[derive(Eq, Hash, EqIgnoreSpan)]
#[cfg_attr(feature = &quot;arbitrary&quot;, derive(arbitrary::Arbitrary))]
pub struct TsTplLitType {
    // ...
}
</code></pre>
<pre><code class="lang-rust">// https://github.com/swc-project/swc/blob/828190c035d61e6521280e2260c511bc02b81327/crates/swc_ecma_ast/src/expr.rs#L1060
#[ast_node(&quot;TemplateLiteral&quot;)]
#[derive(Eq, Hash, EqIgnoreSpan)]
#[cfg_attr(feature = &quot;arbitrary&quot;, derive(arbitrary::Arbitrary))]
pub struct Tpl {
    pub span: Span,

    #[cfg_attr(feature = &quot;serde-impl&quot;, serde(rename = &quot;expressions&quot;))]
    pub exprs: Vec&lt;Box&lt;Expr&gt;&gt;,

    pub quasis: Vec&lt;TplElement&gt;,
}
</code></pre>
<p>These two types need to be handled separately and not generated by a script.</p>
<p>Implement both <code>TemplateLiteral</code>, <code>TsTemplateLiteralType</code> by one class. When used, it is then up-converted to <code>TemplateLiteral</code>, <code>TsTemplateLiteralType</code>.</p>
<pre><code class="lang-kotlin">// ignore annotation
interface TemplateLiteral : ExpressionBase, Expression {
    var expressions: Array&lt;Expression&gt;?
    var quasis: Array&lt;TemplateElement&gt;?
    override var span: Span?
}

interface TsTemplateLiteralType : Node, HasSpan, TsLiteral {
    var types: Array&lt;TsType&gt;?
    var quasis: Array&lt;TemplateElement&gt;?
    override var span: Span?
}

class TemplateLiteralImpl : TemplateLiteral, TsTemplateLiteralType {
    override var types: Array&lt;TsType&gt;? = null
    override var expressions: Array&lt;Expression&gt;? = null
    override var quasis: Array&lt;TemplateElement&gt;? = null
    override var span: Span? = null
}

typealias TsTemplateLiteralTypeImpl = TemplateLiteralImpl
</code></pre>
<h3 id="-parsesync">新的 <code>parseSync</code></h3>
<p>Now we can upgrade the <code>parseSync</code> signature.</p>
<pre><code class="lang-kotlin">@Throws(RuntimeException::class)
fun parseSync(code: String, options: ParserConfig, filename: String?): Program 
</code></pre>
<p>Type safety and type hints are now guaranteed when used.</p>
<pre><code class="lang-kotlin">const program = SwcNative().parseSync(
    &quot;&quot;&quot;
    function App() {
       return &lt;div&gt;App&lt;/div&gt;
    }
    &quot;&quot;&quot;.trimIndent(),
    esParseOptions {
        jsx = true
        target = &quot;es5&quot;
    },
    &quot;temp.js&quot;
)
if (program is Module) {
    if (program.body?.get(0) is FunctionDeclaration) {
        // ...
    }
}
</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>Here, we have explained the idea and core implementation points of SWC JVM binding: 1. SWC supports JNI; 2. AST JSON is serialized into Kotlin classes; 3. ASTs and configurations are described through DSL.</p>
<p>Some details are not covered, such as the handling of boundary cases in Kotlin generated scripts, Rust cross-compilation, etc. For more details, you can read the source code. If you are interested in the details, you can read the source code <a href="https://github.com/yidafu/swc-binding">yidafu/swc-binding</a>.</p>
<p>If you need to compile JS in the JVM, SWC JVM binding has been released to the Maven central repository, use <a href="https://mvnrepository.com/artifact/dev.yidafu.swc/">dev.yidafu.swc:swc-binding:0.5.0</a>. swc-binding)</p>
<p>For other questions, feel free to <a href="https://github.com/yidafu/swc-binding/issues/new">mention Issue</a>.</p>
<blockquote>
<p>Thinking never ends.</p>
</blockquote>
</body>
</html>
